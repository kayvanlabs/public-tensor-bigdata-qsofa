function [foundPositiveSignals, foundNegativeSignals] = findOutcomesForQSOFA(qsofaDir, noiseDir, signalsInfo, gapDuration, signalDuration)
% DESCRIPTION
%  Identify positive and negative outcomes for qSOFA
%
% REQUIRES
%   signalsInfo has event time logged for positive cases
%   getUniqueWaveTypes()
%   removeOverlappingIds()
%   getNegativeSignals()
%   createRandomStart()
%   getPositiveSignals()
%   checkIfSignalIsUsable()
%
% INPUT
%   qsofaDir: string, location of each qsofa file generated by createQSOFA.m
%   noiseDir: string, location of noise files generated by noiseCheck.m
%   signalsInfo: table of waveformTimes data
%   gapDuration: duration, time between end of prediction signal and event
%   signalDuration: duration, desired length of prediction signal
%
% OUTPUT
%   foundPositiveSignals: table of identified positive signals
%   foundNegativeSignals: table of identified negative signals
%
% Olivia Pifer Alge for BCIL
% March 2022

    %% Set RNG for consistency
    rng(0);
    
    %% Load required scripts
    addpath('../GeneralProcessing/');
    addpath('findOutcomes/');
    
    %% Set parameters
    % Only use 1st instance of event identified
    onlyUseUnique = false;
    % Use 1st instance per Sepsis and Enc ID
    onlyUseFirstPerEnc = false;
    
    % Create variables to more easily access columns
    % Identity
    idCol = "SepsisID";
    encCol = "Sepsis_EncID";
    dateCol = "ObservationDate";
    % Signal-specific informatoin
    obsCol =  dateCol;  % For qSOFA, dateCol is the event time
    startCol = "StartTime";  % Start time of waveform
    endCol = "EndTime";  % End time of waveform
    waveCol = "WaveType";
    waveIdCol = "WaveID";
    availBeforeCol = "availableBeforeQSOFA";
    
    % Information about waveforms
    uniqueWaveTypes = getUniqueWaveTypes(signalsInfo, waveCol);
    nWaveTypes = size(uniqueWaveTypes, 1);
    
    %% Initialize output
    foundPositiveSignals = [];
    foundNegativeSignals = [];
    
    %% Load in data
    qsofaTable = createQsofaTable(qsofaDir);
    
    %% Modify data if needed
    if ~strcmp(signalsInfo.Properties.VariableNames{1}, idCol)
        signalsInfo = changeColNameWithIndex(signalsInfo, 1, idCol);
    end
    if ~strcmp(qsofaTable.Properties.VariableNames{2}, encCol)
        qsofaTable = changeColNameWithIndex(qsofaTable, 2, encCol);
    end
    
    if onlyUseUnique || onlyUseFirstPerEnc
        qsofaTable = removeOverlappingIds(qsofaTable, idCol, encCol, obsCol, onlyUseUnique);
    end
    
    %% Find which IDs are marked in both WaveformTimes and qSOFA
    uniqueIdsQsofa = unique(qsofaTable(:, [idCol, encCol]));
    uniqueIdsSigInfo = [signalsInfo(:, [idCol, encCol])];
    uniqueIdsSigInfo.(encCol) = str2double(uniqueIdsSigInfo.(encCol));
    sharedIds = ismember(uniqueIdsQsofa, uniqueIdsSigInfo, 'rows');
    sharedIds = uniqueIdsQsofa(sharedIds, :);
    
    %% Main loop of function, iterate per ID
    for i = 1:size(sharedIds, 1)
        iId = sharedIds{i, idCol};
        iEnc = sharedIds{i, encCol};
        iRows = (qsofaTable{:, idCol} == iId) & (qsofaTable{:, encCol} == iEnc);
        iEvent = qsofaTable(iRows, :);
        iRows = (signalsInfo{:, idCol} == iId) & ...
                 (str2double(signalsInfo{:, encCol}) == iEnc);
        iWavefms = signalsInfo(iRows, :);
        
        % Handle if there are missing wave types
        nWavesUnique = size(unique(iWavefms.(waveCol)), 1);
        if (nWavesUnique ~= nWaveTypes)
            if nWavesUnique < nWaveTypes || isempty(iWavefms)
                disp(['Missing Signals for ID_', num2str(iId), '_E_', num2str(iEnc)])
                if ~all(isnat(iEvent.(obsCol)))
                    iPositiveSignals = makeBlankTestRow(iEvent(1, :));
                    iPositiveSignals.(encCol) = iPositiveSignals.(encCol) + "_Missing";
                    foundPositiveSignals = [foundPositiveSignals; iPositiveSignals];
                end
                continue
            else
                error('Some error is occurring with regard to signal types')
            end
        end
        
        % Find outcomes based on presence of event
        for j = 1:size(iEvent, 1)  % For each event
            jStart = iEvent{j, obsCol};
            if isnat(jStart)
                iNegativeSignals = getNegativeSignals(noiseDir, signalDuration,...
                                                      gapDuration, ...
                                                      iWavefms, iEvent(j, :), ...
                                                      startCol, endCol, ...
                                                      idCol, encCol, ...
                                                      waveCol, waveIdCol, ...
                                                      onlyUseFirstPerEnc);
                foundNegativeSignals = [foundNegativeSignals; iNegativeSignals];
            else
                iPositiveSignals = getPositiveSignals(noiseDir, signalDuration,...
                                                      gapDuration, ...
                                                      iWavefms, iEvent(j, :), ...
                                                      startCol, endCol, ...
                                                      obsCol, idCol, encCol, ...
                                                      waveCol, waveIdCol, availBeforeCol);
                if isempty(iPositiveSignals)
                    disp(['Signal outside of desired time for ID_', num2str(iId), '_E_', num2str(iEnc)])
                    iPositiveSignals = makeBlankTestRow(iEvent(j, :));
                    iPositiveSignals.(encCol) = iPositiveSignals.(encCol) + "_OOB";
                end
                foundPositiveSignals = [foundPositiveSignals; iPositiveSignals];
            end
        end
    end
    disp(size(foundPositiveSignals, 1))
end % eof

%% Helper functions

function qsofaTable = createQsofaTable(qsofaDir)
% DESCRIPTION
% Load in qSOFA tables sequentially and merge them together
%
% REQUIRES
%   loadYearTable()
%
% INPUT
%   qsofaDir: string, location where qSOFA files are stored
%
% OUTPUT
%   qsofaTable: table containing all qSOFA year files' information

    baseName = 'qsofa';
    q14 = loadYearTable(14, qsofaDir, baseName);
    q15 = loadYearTable(15, qsofaDir, baseName);
    q16 = loadYearTable(16, qsofaDir, baseName);
    q17 = loadYearTable(17, qsofaDir, baseName);
    q18 = loadYearTable(18, qsofaDir, baseName);
    
    qsofaTable = [q14; q15; q16; q17; q18];
end

function tableOut = loadYearTable(yearNum, dataDir, baseName)
% DESCRIPTION
% Function to load in stored data of different years
%
% REQIRES
% file stored in dataDir follows naming convention '<baseName><yearNum>.mat'
%     e.g. if baseName == 'test' and yearNum == 20, 'test20.mat'
% loaded file from disk has only one field
%
% INPUT
%   yearNum: numeric, last 2 digits of year for data file
%   dataDir: string, location where data is stored
%
% OUTPUT
% tableOut: table loaded from file
    yearStr = num2str(yearNum);
    tableOut = load(fullfile(dataDir, append(baseName, yearStr, '.mat')));
    fNames = fieldnames(tableOut);
    tableOut = tableOut.(fNames{1});
    tableOut.yearFile = repelem(yearNum, size(tableOut, 1))';
    columnOrder = {'SepsisID', 'EncID', 'ObservationDate', ...
                   'BPSysNonInvasive', 'BPSysInvasive', 'RespiratoryRate', ...
                   'GCS', 'qSofaEncoding', 'qSofaTotal', 'yearFile'};
    tableOut = tableOut(:, columnOrder);
end

function blankTest = makeBlankTestRow(jEvent)
    blankTest = jEvent(:, ["SepsisID", "ObservationDate", "BPSysNonInvasive", ...
                           "BPSysInvasive", "RespiratoryRate", "GCS", ...
                           "qSofaEncoding", "qSofaTotal", "yearFile", ...
                           "Sepsis_EncID"]);
    blankTest.WaveType = "";
    blankTest.WaveID = "";
    blankTest.StartTime = NaT('TimeZone', jEvent.ObservationDate.TimeZone);
    blankTest.EndTime = blankTest.StartTime;
    blankTest.DurationStartMinusEnd = seconds(0);
    blankTest.Duration = seconds(0);
    blankTest.TimeStampDuration_minus_Duration = seconds(0);
    blankTest.AbsVal_TimeStampDur_minus_Duration = seconds(0);
    blankTest.availableBeforeQSOFA = seconds(0);
    blankTest.predictionSignalStart = blankTest.StartTime;
    blankTest.predictionSignalEnd = blankTest.StartTime;
end