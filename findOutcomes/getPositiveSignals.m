function positiveSignals = getPositiveSignals(noiseDir, signalDuration, gapDuration, wavTab, thisEvent, startCol, endCol, obsCol, idCol, encCol, waveCol, waveIdCol, availBeforeCol) 
% DESCRIPTION
% Find positive cases
%
% REQUIRES
% iWavems.(waveCol) is of type 'EKG II' or 'Art Line'
% checkIfSignalUsable()
%
% INPUT
%   noiseDir: string, location of noise files generated by checkNoise()
%   signalDuration: duration, desired length of precdiction signal
%   gapDuration: duration, time between end of prediction signal and event
%   wavTab: table, waveform times
%   thisEvent: table, event information from find<event>Occurrences.m
%   startCol: string, column of wavTab with start time of full signal
%   endCol: string, column of wavTab with end time of full signal
%   obsCol: string, column of event time
%   idCol: string, column of wavTab/thisEvent with SepsisID
%   encCol: string, column of wavTab/thisEvent with EncID
%   waveCol: string, column of wavTab for Wave Type
%   waveIdCol: string, column of wavTab for Wave ID
%   availBeforeCol: string, column of time in signal before event in obsCol
%
% OUTPUT
%   positiveSignals: table merged from wavTab and thisEvent with signal
%       information for events
    positiveSignals = [];
    pSigStart = 'predictionSignalStart';
    pSigEnd = 'predictionSignalEnd';
    predictionSignalEnd = thisEvent.(obsCol) - gapDuration;
    predictionSignalStart = predictionSignalEnd - signalDuration;
    signalEndsBeforeDesiredTime = wavTab.(endCol) < predictionSignalEnd;
    signalStartsAfterDesiredTime = predictionSignalStart < wavTab.(startCol);
    timesDoAgree = (~signalStartsAfterDesiredTime & ~signalEndsBeforeDesiredTime);
    waveTypes = getUniqueWaveTypes(wavTab, waveCol);
    
    if sum(timesDoAgree) >= length(waveTypes) && all(ismember(waveTypes, wavTab{timesDoAgree,waveCol}))
        jWavefms = wavTab(timesDoAgree, :);
        thisEvent.(encCol) = [];
        newRows = innerjoin(thisEvent, jWavefms);
        availBefore = (newRows.(obsCol) - newRows.(startCol)) - ...
                    (max(newRows.(obsCol) - newRows.(endCol), seconds(0)));
        newRows.(availBeforeCol) = availBefore;

        rList = 1:size(newRows, 1);
        ekgRows = strcmp(newRows.(waveCol), 'EKG II');
        artRows = strcmp(newRows.(waveCol), 'Art Line');
        arList = rList(artRows);
        rList = rList(ekgRows);
        % There are rare cases where multiple signals are in the desired
        % time range
        for j = 1:sum(ekgRows)
            jEkg = rList(j);
            if checkIfSignalUsable(noiseDir, jWavefms, predictionSignalStart, ...
                                   predictionSignalEnd, newRows{jEkg, idCol}, ...
                                   newRows{jEkg, encCol}, ...
                                   newRows{jEkg, waveCol}, ...
                                   newRows{jEkg,waveIdCol})
                rowsToAdd = newRows(jEkg, :);
                if any(artRows)
                   aIdx = min(length(arList), j);
                   rowsToAdd = [rowsToAdd; newRows(arList(aIdx), :)];
                end
                nRows = size(rowsToAdd, 1);
                rowsToAdd.(pSigStart) = repelem(predictionSignalStart, nRows)';
                rowsToAdd.(pSigEnd) = repelem(predictionSignalEnd, nRows)';
                positiveSignals = rowsToAdd;
                return  % Return if usable signal is found
            end
        end
    end
end
