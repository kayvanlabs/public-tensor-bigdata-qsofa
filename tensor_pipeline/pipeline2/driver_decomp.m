% DESCRIPTION: This function is called in script_tensor_decomp.sh and it
% loads tensors, constructs feature vectors, and saves them in the correct
% experiment folder. The main parameters, in addition to the data set being
% used, should be set within the load_<data_set>_tensors.m file. This file
% must load in a data table and a params dictionary, which contains
% arguments for:
%   1. Ranks: Ranks for CP decomposition (set as an array)
%   2. CP ALS Rank: do not modify this in the load file. It is
%      automatically set per decomposition
%   3. HOSVD Modes: 0 if no HOSVD in this mode, 1 otherwise
%   4. HOSVD Errors: a parameter for the tolerance of the HOSVD
%      reconstructio
%   5. Non-Tensor-Features: A flag if non-tensor based features in the data
%      table should be included in the feature vectors
%   6. Feature Mode: The mode representing the features extracted from the
%      signals when constructing the tensor.
%
% IMPORTANT: It is necessary to load the tensors into this function in the
% correct table format where the table has 4 main fields:
%   1. Ids: ID of source used to generate the tensor
%   2. Labels: Label of tensor objects for classification
%   3. Tensors: Tensor objects
%   4. Non tensor features: additional features to be included in the
%      vectors
% The Ids column is used in the function cv_split_ids which makes sure all
% samples generated by the same data source (patients) occur in the same
% fold. This function returns feature vectors for 5 fold cross validation.
%
% SAMPLE INPUT: data_set = "CWR"; experiment_name = "NOHOSVD_D"; array_idx=2;
%
% Joshua Pickard (jpic@umich.edu)
%
function driver_decomp(data_set, experiment_name, num_windows, doHOSVD, array_idx)

disp(data_set);
disp(experiment_name);
disp(string(array_idx));

description = strvcat({...
    '                              PIPELINE-2'...
    '######################################################################'...
    'Created by: Joshua Pickard'...
    'Date: 2/16/2022'...
    ' '...
    'This script decomposes tensors into feature vectors.'...
    '######################################################################'...
    ' '...
    });
disp(description)

% Set randome seed for array jobs
rng(array_idx);
disp("Random seed set with rng(" + num2str(array_idx) + ")");

% Load in the data
[tensor_map, params, ~] = load_tensors(data_set, experiment_name, doHOSVD, array_idx);
disp('Data loaded')

data_path = load_data_path(data_set);

% decompositions & vectorization of the data
%true_labels = table([],[],[],'VariableNames',{'Number of Windows','Fold','True Lables'});
feature_vectors = table([],[],[],[],[],[],[],[],[],[],'VariableNames',{'Num_Windows','Decomp','Fold','Rank','Training_X','Training_Y','Validation_X','Validation_Y','Test_X','Test_Y'});

ranks = params('Ranks'); % These should be stored as dataset parameters
num_folds = 3;

disp("Decompositions beginning")

idCols = {'Ids', 'EncID'};

disp('Number of Windows: ' + string(num_windows));
data_table = tensor_map(string(num_windows));

%%
if ismember('train_ids', params.keys)
    paramsTrain = params('train_ids');
    testIdx = ismember(data_table(:, idCols), params('test_ids'));
    trainIdx = ismember(data_table(:, idCols), paramsTrain);
    test_table = data_table(testIdx, :);
    train_val_rows = data_table(trainIdx, :);
    allFolds = params('folds');
    training_idxs = repelem(false, num_folds, size(train_val_rows, 1));
    
    for i = 1:num_folds
        iFold = allFolds(i, :);
        iTrainFoldParams = paramsTrain(iFold, :);
        iLogical = ismember(train_val_rows(:, idCols), iTrainFoldParams);
        training_idxs(i, :) = iLogical';
    end
else
    train_test_cv = cv_split_ids_divided(data_table, num_folds + 1);
    test_table = data_table(~train_test_cv(1, :), :);
    train_val_rows = data_table(train_test_cv(1, :), :);
    if any(ismember(test_table.Ids, train_val_rows.Ids))
        error('Overlap between train and test')
    end
    training_idxs = cv_split_ids_divided(train_val_rows, num_folds);
end

testIds = test_table(:, idCols);
trainIds = train_val_rows(:, idCols);

%%
for fold=1:num_folds
    disp('FOLD:' + string(fold));
    fold_train_indices = training_idxs(fold,:);
    fold_val_indices = ~training_idxs(fold,:);
    train_table = train_val_rows(fold_train_indices,:);
    val_table = train_val_rows(fold_val_indices,:);
    if any(ismember(train_table.Ids, val_table.Ids))
        error('Overlap between train and validation')
    end
    parfor decomp=1:(length(ranks)+1)
        disp('DECOMP/RANK: ' + string(decomp));
        if decomp < length(ranks)+1
            % Put in tensors
            rank = ranks(decomp);
            params_temp = params;
            params_temp('CP ALS Rank') = rank;
            [train_X, train_y, test_X, test_y, val_X, val_y] = tensor_method(train_table, test_table, val_table, params_temp);
            feature_vectors = [feature_vectors; {num_windows, 'Tensor', fold, rank, train_X, train_y, val_X, val_y, test_X, test_y}];
        else
            % Put in vectorization
            [train_X, train_y, test_X, test_y, val_X, val_y] = vectorize_data(train_table, test_table, val_table, params);
            feature_vectors = [feature_vectors; {num_windows, 'Vector', fold, 0, train_X, train_y, val_X, val_y, test_X, test_y}];
        end
    end
    % Stop here for debugging
    save(char(data_path + experiment_name + "/feature_vectors_" + string(array_idx) + ".mat"), 'feature_vectors','-v7.3');
end

save(char(data_path + experiment_name + "/feature_vectors_" + string(array_idx) + ".mat"), 'feature_vectors', 'trainIds', 'testIds', 'training_idxs', '-v7.3');

disp('Feature vectors creates and saved')
disp('Job Complete')

end